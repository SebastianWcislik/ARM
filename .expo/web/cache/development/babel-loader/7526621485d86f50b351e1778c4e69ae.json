{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport { AsyncStorage } from '@react-native-community/async-storage';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport ExponentNotifications from \"./ExponentNotifications\";\n\nvar _emitter;\n\nvar _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  notification = _objectSpread({}, notification);\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {}\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = _extends({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = _extends(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = _extends(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nvar ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\nvar IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nfunction _legacyReadChannel(id) {\n  var channelString;\n  return _regeneratorRuntime.async(function _legacyReadChannel$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(AsyncStorage.getItem(\"\" + ASYNC_STORAGE_PREFIX + id));\n\n        case 3:\n          channelString = _context.sent;\n\n          if (!channelString) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\", JSON.parse(channelString));\n\n        case 6:\n          _context.next = 10;\n          break;\n\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](0);\n\n        case 10:\n          return _context.abrupt(\"return\", null);\n\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[0, 8]], Promise);\n}\n\nfunction _legacyDeleteChannel(id) {\n  return AsyncStorage.removeItem(\"\" + ASYNC_STORAGE_PREFIX + id);\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = function _callee(callback) {\n    var keys, filteredKeys;\n    return _regeneratorRuntime.async(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(AsyncStorage.getAllKeys());\n\n          case 3:\n            keys = _context2.sent;\n\n            if (!(keys && keys.length)) {\n              _context2.next = 8;\n              break;\n            }\n\n            filteredKeys = keys.filter(function (key) {\n              return !key.startsWith(ASYNC_STORAGE_PREFIX);\n            });\n            _context2.next = 8;\n            return _regeneratorRuntime.awrap(AsyncStorage.multiRemove(filteredKeys));\n\n          case 8:\n            callback && callback();\n            _context2.next = 15;\n            break;\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](0);\n            callback && callback(_context2.t0);\n            throw _context2.t0;\n\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 11]], Promise);\n  };\n}\n\nfunction _legacySaveChannel(id, channel) {\n  return AsyncStorage.setItem(\"\" + ASYNC_STORAGE_PREFIX + id, JSON.stringify(channel));\n}\n\nexport default {\n  _setInitialNotification: function _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n  createCategoryAsync: function createCategoryAsync(categoryId, actions) {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n  deleteCategoryAsync: function deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n  getExpoPushTokenAsync: function getExpoPushTokenAsync() {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n  getDevicePushTokenAsync: function getDevicePushTokenAsync(config) {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n  createChannelAndroidAsync: function createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \" + Platform.OS);\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n\n    return ExponentNotifications.createChannel(id, channel);\n  },\n  deleteChannelAndroidAsync: function deleteChannelAndroidAsync(id) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"deleteChannelAndroidAsync(...) has no effect on \" + Platform.OS);\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n\n    return ExponentNotifications.deleteChannel(id);\n  },\n  presentLocalNotificationAsync: function presentLocalNotificationAsync(notification) {\n    var nativeNotification, _channel;\n\n    return _regeneratorRuntime.async(function presentLocalNotificationAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _validateNotification(notification);\n\n            nativeNotification = _processNotification(notification);\n\n            if (!(Platform.OS !== 'android')) {\n              _context3.next = 8;\n              break;\n            }\n\n            _context3.next = 5;\n            return _regeneratorRuntime.awrap(ExponentNotifications.presentLocalNotification(nativeNotification));\n\n          case 5:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 8:\n            if (!nativeNotification.channelId) {\n              _context3.next = 12;\n              break;\n            }\n\n            _context3.next = 11;\n            return _regeneratorRuntime.awrap(_legacyReadChannel(nativeNotification.channelId));\n\n          case 11:\n            _channel = _context3.sent;\n\n          case 12:\n            if (!IS_USING_NEW_BINARY) {\n              _context3.next = 17;\n              break;\n            }\n\n            _legacyDeleteChannel(nativeNotification.channelId);\n\n            return _context3.abrupt(\"return\", ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel));\n\n          case 17:\n            if (_channel) {\n              nativeNotification.sound = _channel.sound;\n              nativeNotification.priority = _channel.priority;\n              nativeNotification.vibrate = _channel.vibrate;\n            }\n\n            return _context3.abrupt(\"return\", ExponentNotifications.presentLocalNotification(nativeNotification));\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleLocalNotificationAsync: function scheduleLocalNotificationAsync(notification) {\n    var options,\n        now,\n        nativeNotification,\n        timeAsDateObj,\n        validOptions,\n        _channel,\n        _args4 = arguments;\n\n    return _regeneratorRuntime.async(function scheduleLocalNotificationAsync$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n            now = Date.now();\n\n            _validateNotification(notification);\n\n            nativeNotification = _processNotification(notification);\n\n            if (!options.time) {\n              _context4.next = 11;\n              break;\n            }\n\n            timeAsDateObj = null;\n\n            if (options.time && typeof options.time === 'number') {\n              timeAsDateObj = new Date(options.time);\n\n              if (timeAsDateObj.toString() === 'Invalid Date') {\n                timeAsDateObj = null;\n              }\n            } else if (options.time && options.time instanceof Date) {\n              timeAsDateObj = options.time;\n            }\n\n            if (timeAsDateObj) {\n              _context4.next = 9;\n              break;\n            }\n\n            throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n\n          case 9:\n            if (timeAsDateObj.getTime() < now) {\n              console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n            }\n\n            options = _objectSpread(_objectSpread({}, options), {}, {\n              time: timeAsDateObj.getTime()\n            });\n\n          case 11:\n            if (!(options.intervalMs != null && options.repeat != null)) {\n              _context4.next = 13;\n              break;\n            }\n\n            throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n\n          case 13:\n            if (!(options.repeat != null)) {\n              _context4.next = 17;\n              break;\n            }\n\n            validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n\n            if (validOptions.has(options.repeat)) {\n              _context4.next = 17;\n              break;\n            }\n\n            throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n\n          case 17:\n            if (!(options.intervalMs != null)) {\n              _context4.next = 22;\n              break;\n            }\n\n            if (!(Platform.OS === 'ios')) {\n              _context4.next = 20;\n              break;\n            }\n\n            throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n\n          case 20:\n            if (!(options.intervalMs <= 0 || !Number.isInteger(options.intervalMs))) {\n              _context4.next = 22;\n              break;\n            }\n\n            throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n\n          case 22:\n            if (!(Platform.OS !== 'android')) {\n              _context4.next = 29;\n              break;\n            }\n\n            if (!options.repeat) {\n              _context4.next = 26;\n              break;\n            }\n\n            console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n            return _context4.abrupt(\"return\", ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options));\n\n          case 26:\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n          case 29:\n            if (!nativeNotification.channelId) {\n              _context4.next = 33;\n              break;\n            }\n\n            _context4.next = 32;\n            return _regeneratorRuntime.awrap(_legacyReadChannel(nativeNotification.channelId));\n\n          case 32:\n            _channel = _context4.sent;\n\n          case 33:\n            if (!IS_USING_NEW_BINARY) {\n              _context4.next = 38;\n              break;\n            }\n\n            _legacyDeleteChannel(nativeNotification.channelId);\n\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel));\n\n          case 38:\n            if (_channel) {\n              nativeNotification.sound = _channel.sound;\n              nativeNotification.priority = _channel.priority;\n              nativeNotification.vibrate = _channel.vibrate;\n            }\n\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n          case 40:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  dismissNotificationAsync: function dismissNotificationAsync(notificationId) {\n    return _regeneratorRuntime.async(function dismissNotificationAsync$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (ExponentNotifications.dismissNotification) {\n              _context5.next = 2;\n              break;\n            }\n\n            throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n\n          case 2:\n            _context5.next = 4;\n            return _regeneratorRuntime.awrap(ExponentNotifications.dismissNotification(notificationId));\n\n          case 4:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  dismissAllNotificationsAsync: function dismissAllNotificationsAsync() {\n    return _regeneratorRuntime.async(function dismissAllNotificationsAsync$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (ExponentNotifications.dismissAllNotifications) {\n              _context6.next = 2;\n              break;\n            }\n\n            throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n\n          case 2:\n            _context6.next = 4;\n            return _regeneratorRuntime.awrap(ExponentNotifications.dismissAllNotifications());\n\n          case 4:\n            return _context6.abrupt(\"return\", _context6.sent);\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  cancelScheduledNotificationAsync: function cancelScheduledNotificationAsync(notificationId) {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n  cancelAllScheduledNotificationsAsync: function cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n  addListener: function addListener(listener) {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      var initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(function () {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n  getBadgeNumberAsync: function getBadgeNumberAsync() {\n    return _regeneratorRuntime.async(function getBadgeNumberAsync$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (ExponentNotifications.getBadgeNumberAsync) {\n              _context7.next = 2;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", 0);\n\n          case 2:\n            return _context7.abrupt(\"return\", ExponentNotifications.getBadgeNumberAsync());\n\n          case 3:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  setBadgeNumberAsync: function setBadgeNumberAsync(number) {\n    return _regeneratorRuntime.async(function setBadgeNumberAsync$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (ExponentNotifications.setBadgeNumberAsync) {\n              _context8.next = 2;\n              break;\n            }\n\n            throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n\n          case 2:\n            return _context8.abrupt(\"return\", ExponentNotifications.setBadgeNumberAsync(number));\n\n          case 3:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleNotificationWithCalendarAsync: function scheduleNotificationWithCalendarAsync(notification) {\n    var options,\n        areOptionsValid,\n        _args9 = arguments;\n    return _regeneratorRuntime.async(function scheduleNotificationWithCalendarAsync$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n            areOptionsValid = (options.month == null || isInRangeInclusive(options.month, 1, 12)) && (options.day == null || isInRangeInclusive(options.day, 1, 31)) && (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) && (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) && (options.second == null || isInRangeInclusive(options.second, 0, 59)) && (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) && (options.weekDay == null || options.day == null);\n\n            if (areOptionsValid) {\n              _context9.next = 4;\n              break;\n            }\n\n            throw new CodedError('WRONG_OPTIONS', 'Options in scheduleNotificationWithCalendarAsync call were incorrect!');\n\n          case 4:\n            return _context9.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithCalendar(notification, options));\n\n          case 5:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleNotificationWithTimerAsync: function scheduleNotificationWithTimerAsync(notification, options) {\n    return _regeneratorRuntime.async(function scheduleNotificationWithTimerAsync$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(options.interval < 1)) {\n              _context10.next = 2;\n              break;\n            }\n\n            throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n\n          case 2:\n            return _context10.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithTimer(notification, options));\n\n          case 3:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\n\nfunction isInRangeInclusive(variable, min, max) {\n  return variable >= min && variable <= max;\n}","map":{"version":3,"sources":["../../src/Notifications/Notifications.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { AsyncStorage, Platform } from 'react-native';\nimport { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport ExponentNotifications from './ExponentNotifications';\nimport {\n  Notification,\n  LocalNotification,\n  Channel,\n  ActionType,\n  LocalNotificationId,\n} from './Notifications.types';\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nlet ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nlet IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    let channelString = await AsyncStorage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return AsyncStorage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = async function(callback?: (error?: Error) => void): Promise<void> {\n    try {\n      let keys = await AsyncStorage.getAllKeys();\n      if (keys && keys.length) {\n        let filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await AsyncStorage.multiRemove(filteredKeys);\n      }\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return AsyncStorage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  // User passes set of actions titles.\n  createCategoryAsync(categoryId: string, actions: ActionType[]): Promise<void> {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId: string): Promise<void> {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n    if (!Constants.isDevice) {\n      throw new Error(`Must be on a physical device to get an Expo Push Token`);\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: (config: {\n    gcmSenderId?: string;\n  }): Promise<{ type: string; data: string }> => {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`createChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`deleteChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    if (Platform.OS !== 'android') {\n      return await ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(\n          nativeNotification,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj: Date | null = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      if (timeAsDateObj.getTime() < now) {\n        console.warn(\n          `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n        );\n      }\n\n      options = {\n        ...options,\n        time: timeAsDateObj.getTime(),\n      };\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'android') {\n      if (options.repeat) {\n        console.warn(\n          'Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.'\n        );\n        return ExponentNotifications.legacyScheduleLocalRepeatingNotification(\n          nativeNotification,\n          options\n        );\n      }\n\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          nativeNotification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (!ExponentNotifications.dismissNotification) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n    }\n    return await ExponentNotifications.dismissNotification(notificationId);\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (!ExponentNotifications.dismissAllNotifications) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n    }\n    return await ExponentNotifications.dismissAllNotifications();\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener(listener: (notification: Notification) => unknown): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n\n  async scheduleNotificationWithCalendarAsync(\n    notification: LocalNotification,\n    options: {\n      year?: number;\n      month?: number;\n      hour?: number;\n      day?: number;\n      minute?: number;\n      second?: number;\n      weekDay?: number;\n      repeat?: boolean;\n    } = {}\n  ): Promise<string> {\n    const areOptionsValid: boolean =\n      (options.month == null || isInRangeInclusive(options.month, 1, 12)) &&\n      (options.day == null || isInRangeInclusive(options.day, 1, 31)) &&\n      (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) &&\n      (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) &&\n      (options.second == null || isInRangeInclusive(options.second, 0, 59)) &&\n      (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) &&\n      (options.weekDay == null || options.day == null);\n\n    if (!areOptionsValid) {\n      throw new CodedError(\n        'WRONG_OPTIONS',\n        'Options in scheduleNotificationWithCalendarAsync call were incorrect!'\n      );\n    }\n\n    return ExponentNotifications.scheduleNotificationWithCalendar(notification, options);\n  },\n\n  async scheduleNotificationWithTimerAsync(\n    notification: LocalNotification,\n    options: {\n      interval: number;\n      repeat?: boolean;\n    }\n  ): Promise<string> {\n    if (options.interval < 1) {\n      throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n    }\n    return ExponentNotifications.scheduleNotificationWithTimer(notification, options);\n  },\n};\n\nfunction isInRangeInclusive(variable: number, min: number, max: number): boolean {\n  return variable >= min && variable <= max;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}